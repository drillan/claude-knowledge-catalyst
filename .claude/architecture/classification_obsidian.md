---
author: null
category: concept
claude_feature:
- code-generation
- analysis
claude_model: []
complexity: advanced
confidence: high
created: 2025-06-19 00:00:00
domain:
- ai-ml
- automation
- data-science
- mobile
- testing
- web-dev
project: claude-knowledge-catalyst
projects:
- claude-knowledge-catalyst
purpose: Auto-generated metadata for classification_obsidian
quality: high
status: draft
subcategory: Development_Patterns
success_rate: null
tags:
- architecture
- design
- ff6b6b
- structure
- system
team: []
tech:
- api
- aws
- git
- javascript
- python
- typescript
title: Classification Obsidian
type: prompt
updated: 2025-06-21 00:04:32.043003
version: '1.0'
---

# åˆ†é¡ã‚·ã‚¹ãƒ†ãƒ ã¨Obsidiançµ±åˆ

## æ¦‚è¦

CKC ã®åˆ†é¡ã‚·ã‚¹ãƒ†ãƒ ã¯ã€çŸ¥è­˜ã®**è‡ªç„¶é€²åŒ–**ã¨**æ®µéšçš„æ§‹é€ åŒ–**ã‚’æ”¯æ´ã™ã‚‹æ ¸å¿ƒæ©Ÿèƒ½ã§ã™ã€‚ã‚«ã‚ªã‚¹ã‹ã‚‰ç§©åºã¸ã®çŸ¥è­˜é€²åŒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’è‡ªå‹•åŒ–ã—ã€Obsidian ã¨ã® deep integration ã«ã‚ˆã‚Šã€ãƒ‘ãƒ¯ãƒ•ãƒ«ãªçŸ¥è­˜ç®¡ç†ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

## è¨­è¨ˆå“²å­¦ï¼šãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ§‹é€ ã‚·ã‚¹ãƒ†ãƒ 

### 1. 10-Step Numbering System

```
00_Catalyst_Lab      # å®Ÿé¨“ãƒ»ã‚¢ã‚¤ãƒ‡ã‚¢å­µåŒ–ã®å ´
10_Projects          # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
20_Knowledge_Base    # ä½“ç³»åŒ–ã•ã‚ŒãŸçŸ¥è¦‹
30_Wisdom_Archive    # é«˜å“è³ªãªçŸ¥è­˜è³‡ç”£
_templates           # ã‚·ã‚¹ãƒ†ãƒ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
Analytics            # çŸ¥è¦‹ã®æ´»ç”¨çŠ¶æ³åˆ†æ
Archive              # å¤ã„ãƒ»éæ¨å¥¨ã®çŸ¥è¦‹
```

ã“ã®æ•°å­—ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€**çŸ¥è­˜ã®æˆç†Ÿåº¦**ã¨**ã‚¢ã‚¯ã‚»ã‚¹é »åº¦**ã‚’è¦–è¦šçš„ã«è¡¨ç¾ã—ã€è‡ªç„¶ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### 2. çŸ¥è­˜é€²åŒ–ã‚¹ãƒ†ãƒ¼ã‚¸

```
Raw Ideas â†’ Structured Insights â†’ Validated Knowledge â†’ Wisdom Assets
   (00)         (10-20)              (20-30)            (30+)

â”œâ”€ 00_Catalyst_Lab/
â”‚  â”œâ”€ brainstorming/         # æœªåŠ å·¥ã‚¢ã‚¤ãƒ‡ã‚¢
â”‚  â”œâ”€ experiments/           # å®Ÿé¨“çš„å–ã‚Šçµ„ã¿
â”‚  â””â”€ rapid_prototypes/      # è¿…é€Ÿãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°
â”‚
â”œâ”€ 10_Projects/
â”‚  â”œâ”€ active/                # é€²è¡Œä¸­ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
â”‚  â”œâ”€ planning/              # è¨ˆç”»æ®µéš
â”‚  â””â”€ review/                # ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»è©•ä¾¡æ®µéš
â”‚
â”œâ”€ 20_Knowledge_Base/
â”‚  â”œâ”€ Prompts/              # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆçŸ¥è¦‹
â”‚  â”œâ”€ Code_Snippets/        # ã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³
â”‚  â”œâ”€ Concepts/             # æ¦‚å¿µãƒ»ç†è«–
â”‚  â””â”€ Resources/            # å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹
â”‚
â””â”€ 30_Wisdom_Archive/
   â”œâ”€ Best_Practices/       # ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹é›†
   â”œâ”€ Lessons_Learned/      # æ•™è¨“ã¨åçœ
   â””â”€ Strategic_Insights/   # æˆ¦ç•¥çš„çŸ¥è¦‹
```

## ObsidianVaultManager è©³ç´°

### 1. åˆæœŸåŒ–ã¨ãƒœãƒ«ãƒˆæ§‹é€ 

```python
class ObsidianVaultManager:
    def __init__(self, vault_path: Path, metadata_manager: MetadataManager):
        self.vault_path = Path(vault_path)
        self.metadata_manager = metadata_manager

        # ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ§‹é€ å®šç¾©
        self.vault_structure = {
            "00_Catalyst_Lab": "å®Ÿé¨“ãƒ»ã‚¢ã‚¤ãƒ‡ã‚¢å­µåŒ–ã®å ´",
            "10_Projects": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†",
            "20_Knowledge_Base": "ä½“ç³»åŒ–ã•ã‚ŒãŸçŸ¥è¦‹",
            "20_Knowledge_Base/Prompts": "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé–¢é€£",
            "20_Knowledge_Base/Prompts/Templates": "æ±ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ",
            "20_Knowledge_Base/Prompts/Best_Practices": "æˆåŠŸäº‹ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹",
            "20_Knowledge_Base/Prompts/Improvement_Log": "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ”¹å–„ã®è¨˜éŒ²",
            "20_Knowledge_Base/Code_Snippets": "å†åˆ©ç”¨å¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆ",
            "20_Knowledge_Base/Code_Snippets/Python": "Pythoné–¢é€£",
            "20_Knowledge_Base/Code_Snippets/JavaScript": "JavaScripté–¢é€£",
            "20_Knowledge_Base/Code_Snippets/Bash": "Bash/Shellé–¢é€£",
            "20_Knowledge_Base/Code_Snippets/Other_Languages": "ãã®ä»–è¨€èª",
            "20_Knowledge_Base/Concepts": "AIãƒ»LLMé–¢é€£ã®æ¦‚å¿µæ•´ç†",
            "20_Knowledge_Base/Concepts/API_Design": "APIè¨­è¨ˆåŸå‰‡",
            "20_Knowledge_Base/Concepts/Software_Architecture": "ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢è¨­è¨ˆ",
            "20_Knowledge_Base/Concepts/Development_Practices": "é–‹ç™ºæ‰‹æ³•",
            "20_Knowledge_Base/Resources": "å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹ã¨å¤–éƒ¨å‚è€ƒè³‡æ–™",
            "30_Wisdom_Archive": "é«˜å“è³ªãªçŸ¥è­˜è³‡ç”£",
            "_templates": "ã‚·ã‚¹ãƒ†ãƒ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ",
            "Analytics": "çŸ¥è¦‹ã®æ´»ç”¨çŠ¶æ³åˆ†æ",
            "Archive": "å¤ã„ãƒ»éæ¨å¥¨ã®çŸ¥è¦‹",
        }
```

### 2. ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆåˆ†é¡ã‚·ã‚¹ãƒ†ãƒ 

```python
class IntelligentClassifier:
    def __init__(self, metadata_manager: MetadataManager):
        self.metadata_manager = metadata_manager
        self.classification_rules = self._load_classification_rules()

    def determine_optimal_location(
        self,
        metadata: KnowledgeMetadata,
        content: str
    ) -> Path:
        """æœ€é©é…ç½®å ´æ‰€ã®æ±ºå®š"""

        # 1. æˆç†Ÿåº¦ãƒ™ãƒ¼ã‚¹åˆ†é¡
        maturity_level = self._assess_content_maturity(metadata, content)
        base_dir = self._get_base_directory(maturity_level)

        # 2. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—åˆ†é¡
        content_type = self._classify_content_type(metadata, content)
        subdirectory = self._get_subdirectory(content_type)

        # 3. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯åˆ†é¡ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
        tech_stack = self._identify_tech_stack(metadata, content)
        if tech_stack:
            subdirectory = subdirectory / tech_stack

        return base_dir / subdirectory

    def _assess_content_maturity(
        self,
        metadata: KnowledgeMetadata,
        content: str
    ) -> str:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æˆç†Ÿåº¦ã®è©•ä¾¡"""

        # å®Ÿè¡Œå±¥æ­´ã«ã‚ˆã‚‹æˆç†Ÿåº¦åˆ¤å®š
        if metadata.success_rate and metadata.success_rate >= 90:
            return "30_wisdom"  # é«˜ã„æˆåŠŸç‡ = æˆç†Ÿã—ãŸçŸ¥è¦‹
        elif metadata.status == "production":
            return "20_knowledge"  # æœ¬ç•ªé‹ç”¨ = ä½“ç³»åŒ–ã•ã‚ŒãŸçŸ¥è¦‹
        elif metadata.status in ["tested", "experimental"]:
            return "10_projects"  # ãƒ†ã‚¹ãƒˆæ¸ˆã¿ = ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ®µéš
        else:
            return "00_catalyst"  # ãƒ‰ãƒ©ãƒ•ãƒˆ = å®Ÿé¨“æ®µéš

    def _classify_content_type(
        self,
        metadata: KnowledgeMetadata,
        content: str
    ) -> str:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã®åˆ†é¡"""

        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ã‚«ãƒ†ã‚´ãƒªå„ªå…ˆ
        if metadata.category:
            category_mapping = {
                "prompt": "Prompts",
                "code": "Code_Snippets",
                "concept": "Concepts",
                "resource": "Resources",
                "project_log": "Project_Logs"
            }
            return category_mapping.get(metadata.category, "General")

        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è§£æã«ã‚ˆã‚‹åˆ†é¡
        if "```" in content:  # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®å­˜åœ¨
            return "Code_Snippets"
        elif any(keyword in content.lower() for keyword in ["claude", "prompt", "ai"]):
            return "Prompts"
        elif any(keyword in content.lower() for keyword in ["concept", "theory", "principle"]):
            return "Concepts"
        else:
            return "General"
```

### 3. é«˜åº¦ãªãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼å¼·åŒ–

```python
class ObsidianFrontmatterEnhancer:
    def __init__(self):
        self.obsidian_specific_fields = {
            'aliases': 'ãƒ•ã‚¡ã‚¤ãƒ«ã®åˆ¥åãƒªã‚¹ãƒˆ',
            'cssclass': 'ã‚«ã‚¹ã‚¿ãƒ CSSã‚¯ãƒ©ã‚¹',
            'tags': 'Obsidianã‚¿ã‚°ï¼ˆãƒã‚¹ãƒˆã‚µãƒãƒ¼ãƒˆï¼‰',
            'graph': 'ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã§ã®è¡¨ç¤ºè¨­å®š',
            'kanban-plugin': 'Kanbanãƒœãƒ¼ãƒ‰è¨­å®š',
            'excalidraw-plugin': 'Excalidrawå›³è¡¨è¨­å®š'
        }

    def enhance_frontmatter(
        self,
        base_metadata: KnowledgeMetadata,
        obsidian_config: dict[str, Any]
    ) -> dict[str, Any]:
        """Obsidianå›ºæœ‰ã®ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼å¼·åŒ–"""

        enhanced = base_metadata.model_dump()

        # 1. Obsidianã‚¿ã‚°ã®éšå±¤åŒ–
        enhanced['tags'] = self._create_hierarchical_tags(base_metadata.tags)

        # 2. ã‚¨ã‚¤ãƒªã‚¢ã‚¹è‡ªå‹•ç”Ÿæˆ
        enhanced['aliases'] = self._generate_aliases(base_metadata.title)

        # 3. é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ã®Wiki-linkãƒªã‚¹ãƒˆ
        enhanced['related_files'] = self._generate_wikilinks(base_metadata)

        # 4. å¯è¦–åŒ–è¨­å®š
        enhanced['graph'] = {
            'color': self._get_node_color(base_metadata.category),
            'shape': self._get_node_shape(base_metadata.complexity)
        }

        # 5. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å›ºæœ‰è¨­å®š
        if base_metadata.category == 'project_log':
            enhanced['kanban-plugin'] = self._create_kanban_config(base_metadata)

        return enhanced

    def _create_hierarchical_tags(self, flat_tags: list[str]) -> list[str]:
        """éšå±¤ã‚¿ã‚°ã®ä½œæˆ"""
        hierarchical = []

        for tag in flat_tags:
            if '/' in tag:
                hierarchical.append(tag)
            else:
                # è‡ªå‹•éšå±¤åŒ–ãƒ«ãƒ¼ãƒ«
                if tag in ['python', 'javascript', 'bash']:
                    hierarchical.append(f'tech/{tag}')
                elif tag in ['opus', 'sonnet', 'haiku']:
                    hierarchical.append(f'claude/{tag}')
                elif tag in ['prompt', 'code', 'concept']:
                    hierarchical.append(f'type/{tag}')
                else:
                    hierarchical.append(tag)

        return hierarchical
```

### 4. åŒæ–¹å‘ãƒªãƒ³ã‚¯ã‚·ã‚¹ãƒ†ãƒ 

```python
class BiDirectionalLinkManager:
    def __init__(self, vault_path: Path):
        self.vault_path = vault_path
        self.link_graph = NetworkX.DiGraph()

    def create_intelligent_links(
        self,
        current_file: Path,
        metadata: KnowledgeMetadata
    ) -> list[str]:
        """ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆãªåŒæ–¹å‘ãƒªãƒ³ã‚¯ç”Ÿæˆ"""

        links = []

        # 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé–¢é€£ãƒªãƒ³ã‚¯
        if metadata.project:
            project_files = self._find_project_files(metadata.project)
            links.extend([f"[[{f.stem}]]" for f in project_files])

        # 2. ã‚¿ã‚°ãƒ™ãƒ¼ã‚¹ãƒªãƒ³ã‚¯
        similar_files = self._find_similar_by_tags(metadata.tags, current_file)
        links.extend([f"[[{f.stem}]]" for f in similar_files])

        # 3. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯é–¢é€£ãƒªãƒ³ã‚¯
        semantic_matches = self._find_semantic_matches(current_file)
        links.extend([f"[[{f.stem}]]" for f in semantic_matches])

        # 4. æ”¹å–„å±¥æ­´ãƒªãƒ³ã‚¯ï¼ˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”¨ï¼‰
        if metadata.category == 'prompt':
            version_history = self._find_version_history(current_file)
            links.extend([f"[[{f.stem}]]" for f in version_history])

        return list(set(links))  # é‡è¤‡å‰Šé™¤

    def maintain_link_integrity(self) -> None:
        """ãƒªãƒ³ã‚¯æ•´åˆæ€§ã®ç¶­æŒ"""

        # 1. ç ´æãƒªãƒ³ã‚¯ã®æ¤œå‡ºã¨ä¿®å¾©
        broken_links = self._find_broken_links()
        for link in broken_links:
            self._repair_or_remove_link(link)

        # 2. åŒæ–¹å‘æ€§ã®ä¿è¨¼
        self._ensure_bidirectional_links()

        # 3. ãƒªãƒ³ã‚¯ã‚°ãƒ©ãƒ•ã®æ›´æ–°
        self._update_link_graph()
```

## åŒæœŸã‚·ã‚¹ãƒ†ãƒ 

### 1. HybridSyncManager

```python
class HybridSyncManager:
    def __init__(self, config: CKCConfig):
        self.config = config
        self.sync_targets = self._initialize_sync_targets()
        self.conflict_resolver = ConflictResolver()

    def sync_file(self, source_file: Path) -> SyncResult:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®è¤‡æ•°ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåŒæœŸ"""

        results = []
        metadata = self.metadata_manager.extract_metadata_from_file(source_file)

        for target in self.sync_targets:
            if target.enabled:
                try:
                    # 1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›ºæœ‰ã®å¤‰æ›
                    transformed_content = self._transform_for_target(
                        source_file, metadata, target
                    )

                    # 2. æœ€é©é…ç½®å ´æ‰€ã®æ±ºå®š
                    target_path = self._determine_target_path(
                        metadata, target
                    )

                    # 3. ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ¤œå‡ºã¨è§£æ±º
                    if self._detect_conflict(target_path, transformed_content):
                        resolution = self.conflict_resolver.resolve(
                            source_file, target_path, transformed_content
                        )
                        if resolution.action == 'skip':
                            continue

                    # 4. åŒæœŸå®Ÿè¡Œ
                    self._execute_sync(transformed_content, target_path, target)
                    results.append(SyncResult.success(target.name))

                except Exception as e:
                    results.append(SyncResult.error(target.name, str(e)))

        return SyncResult.aggregate(results)
```

### 2. Obsidianå›ºæœ‰ã®åŒæœŸæ©Ÿèƒ½

```python
class ObsidianSyncFeatures:
    def __init__(self, vault_manager: ObsidianVaultManager):
        self.vault_manager = vault_manager

    def create_moc_files(self) -> None:
        """Map of Content (MOC) ãƒ•ã‚¡ã‚¤ãƒ«ã®è‡ªå‹•ç”Ÿæˆ"""

        # 1. ã‚«ãƒ†ã‚´ãƒªåˆ¥MOC
        for category in ['Prompts', 'Code_Snippets', 'Concepts']:
            self._create_category_moc(category)

        # 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ¥MOC
        projects = self._get_all_projects()
        for project in projects:
            self._create_project_moc(project)

        # 3. ã‚¿ã‚°ãƒ™ãƒ¼ã‚¹MOC
        popular_tags = self._get_popular_tags()
        for tag in popular_tags:
            self._create_tag_moc(tag)

    def _create_category_moc(self, category: str) -> None:
        """ã‚«ãƒ†ã‚´ãƒªMOCã®ä½œæˆ"""

        files = self._get_files_by_category(category)

        moc_content = f"""# {category} Map of Content

## æ¦‚è¦
{category}é–¢é€£ã®çŸ¥è­˜ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§

## é«˜å“è³ªã‚¢ã‚¤ãƒ†ãƒ 
"""

        # æˆåŠŸç‡é †ã§ã‚½ãƒ¼ãƒˆ
        high_quality = sorted(
            [f for f in files if f.metadata.success_rate and f.metadata.success_rate >= 90],
            key=lambda x: x.metadata.success_rate,
            reverse=True
        )

        for file in high_quality:
            moc_content += f"- [[{file.name}]] - {file.metadata.purpose or 'No description'}\n"

        moc_content += "\n## æœ€è¿‘è¿½åŠ \n"

        recent_files = sorted(files, key=lambda x: x.metadata.created, reverse=True)[:10]
        for file in recent_files:
            moc_content += f"- [[{file.name}]] - {file.metadata.created.strftime('%Y-%m-%d')}\n"

        # MOCãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        moc_path = self.vault_manager.vault_path / f"{category}_MOC.md"
        moc_path.write_text(moc_content, encoding='utf-8')
```

### 3. å‹•çš„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ 

```python
class ObsidianTemplateManager:
    def __init__(self, templates_dir: Path):
        self.templates_dir = templates_dir
        self.template_engine = Jinja2Environment()

    def create_obsidian_template(
        self,
        template_type: str,
        metadata: KnowledgeMetadata
    ) -> str:
        """Obsidianå›ºæœ‰ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½œæˆ"""

        template_mapping = {
            'prompt': self._create_prompt_template,
            'code_snippet': self._create_code_template,
            'concept': self._create_concept_template,
            'project_log': self._create_project_template,
            'moc': self._create_moc_template
        }

        creator = template_mapping.get(template_type, self._create_generic_template)
        return creator(metadata)

    def _create_prompt_template(self, metadata: KnowledgeMetadata) -> str:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå°‚ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ"""

        return f"""---
{self._format_frontmatter(metadata)}
aliases:
  - {metadata.title}
tags:
  - type/prompt
  - {'/'.join(metadata.tags)}
graph:
  color: "#ff6b6b"
  shape: "diamond"
---

# {metadata.title}

## ğŸ¯ ç›®çš„
{metadata.purpose or 'TBD'}

## ğŸ“‹ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå†…å®¹

```
[ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæœ¬æ–‡ã‚’ã“ã“ã«è¨˜è¼‰]
```

## ğŸ” å®Ÿè¡Œä¾‹

### å…¥åŠ›
```
[å…¥åŠ›ä¾‹]
```

### å‡ºåŠ›
```
[æœŸå¾…å‡ºåŠ›ä¾‹]
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- **æˆåŠŸç‡**: {metadata.success_rate or 'TBD'}%
- **ä½¿ç”¨ãƒ¢ãƒ‡ãƒ«**: {metadata.model or 'TBD'}
- **ä¿¡é ¼åº¦**: {metadata.confidence or 'TBD'}

## ğŸ”— é–¢é€£ãƒªãƒ³ã‚¯
{self._generate_related_links(metadata)}

## ğŸ“ æ”¹å–„å±¥æ­´
- **v{metadata.version}**: åˆå›ä½œæˆ

## ğŸ·ï¸ ã‚¿ã‚°
{' '.join([f'#{tag}' for tag in metadata.tags])}
"""
```

## Analytics ã¨æœ€é©åŒ–

### 1. ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ

```python
class VaultAnalytics:
    def __init__(self, vault_path: Path):
        self.vault_path = vault_path

    def analyze_usage_patterns(self) -> dict[str, Any]:
        """ãƒœãƒ«ãƒˆä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æ"""

        return {
            'most_accessed_files': self._get_most_accessed(),
            'category_distribution': self._analyze_category_distribution(),
            'link_density': self._calculate_link_density(),
            'knowledge_evolution': self._track_knowledge_evolution(),
            'search_patterns': self._analyze_search_patterns(),
            'creation_patterns': self._analyze_creation_patterns()
        }

    def generate_insights(self) -> list[str]:
        """çŸ¥è¦‹ã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ææ¡ˆ"""

        insights = []
        analysis = self.analyze_usage_patterns()

        # ä½¿ç”¨é »åº¦ã®ä½ã„ã‚«ãƒ†ã‚´ãƒªæ¤œå‡º
        underused_categories = [
            cat for cat, count in analysis['category_distribution'].items()
            if count < 5
        ]
        if underused_categories:
            insights.append(
                f"æ´»ç”¨åº¦ãŒä½ã„ã‚«ãƒ†ã‚´ãƒª: {', '.join(underused_categories)}"
            )

        # å­¤ç«‹ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œå‡º
        isolated_files = [
            f for f, links in analysis['link_density'].items()
            if links == 0
        ]
        if isolated_files:
            insights.append(f"ãƒªãƒ³ã‚¯ãŒä¸è¶³ã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«: {len(isolated_files)}å€‹")

        return insights
```

### 2. è‡ªå‹•æœ€é©åŒ–

```python
class VaultOptimizer:
    def __init__(self, vault_manager: ObsidianVaultManager):
        self.vault_manager = vault_manager

    def optimize_vault_structure(self) -> OptimizationReport:
        """ãƒœãƒ«ãƒˆæ§‹é€ ã®æœ€é©åŒ–"""

        optimizations = []

        # 1. ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®ã®æœ€é©åŒ–
        misplaced_files = self._find_misplaced_files()
        for file in misplaced_files:
            optimal_location = self._determine_optimal_location(file)
            optimizations.append(
                MoveOptimization(file.path, optimal_location)
            )

        # 2. é‡è¤‡ãƒ•ã‚¡ã‚¤ãƒ«ã®çµ±åˆææ¡ˆ
        duplicates = self._find_duplicate_content()
        for duplicate_group in duplicates:
            optimizations.append(
                MergeOptimization(duplicate_group)
            )

        # 3. ã‚¿ã‚°ã®æ­£è¦åŒ–
        tag_normalizations = self._suggest_tag_normalizations()
        optimizations.extend(tag_normalizations)

        return OptimizationReport(optimizations)
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨å¾©æ—§

### 1. åŒæœŸã‚¨ãƒ©ãƒ¼ã®å‡¦ç†

```python
class SyncErrorHandler:
    def __init__(self):
        self.error_handlers = {
            'file_conflict': self._handle_file_conflict,
            'permission_error': self._handle_permission_error,
            'format_error': self._handle_format_error,
            'network_error': self._handle_network_error
        }

    def handle_sync_error(self, error: SyncError) -> ErrorResolution:
        """åŒæœŸã‚¨ãƒ©ãƒ¼ã®è‡ªå‹•å‡¦ç†"""

        handler = self.error_handlers.get(error.type, self._handle_generic_error)
        return handler(error)

    def _handle_file_conflict(self, error: SyncError) -> ErrorResolution:
        """ãƒ•ã‚¡ã‚¤ãƒ«ç«¶åˆã®å‡¦ç†"""

        # 1. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
        backup_path = self._create_backup(error.target_file)

        # 2. å·®åˆ†è§£æ
        diff = self._analyze_differences(error.source_file, error.target_file)

        # 3. è‡ªå‹•ãƒãƒ¼ã‚¸è©¦è¡Œ
        if diff.is_auto_mergeable:
            merged_content = self._auto_merge(diff)
            return ErrorResolution.merged(merged_content)
        else:
            return ErrorResolution.manual_intervention_required(diff)
```

### 2. ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯

```python
class DataIntegrityChecker:
    def __init__(self, vault_path: Path):
        self.vault_path = vault_path

    def check_integrity(self) -> IntegrityReport:
        """ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®åŒ…æ‹¬ãƒã‚§ãƒƒã‚¯"""

        issues = []

        # 1. ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼æ•´åˆæ€§
        frontmatter_issues = self._check_frontmatter_integrity()
        issues.extend(frontmatter_issues)

        # 2. ãƒªãƒ³ã‚¯æ•´åˆæ€§
        link_issues = self._check_link_integrity()
        issues.extend(link_issues)

        # 3. ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ æ•´åˆæ€§
        structure_issues = self._check_structure_integrity()
        issues.extend(structure_issues)

        # 4. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§
        metadata_issues = self._check_metadata_consistency()
        issues.extend(metadata_issues)

        return IntegrityReport(issues)
```

ã“ã®åŒ…æ‹¬çš„ãªåˆ†é¡ãƒ»çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€CKC ã¯çŸ¥è­˜ã®è‡ªç„¶ãªé€²åŒ–ã‚’æ”¯æ´ã—ã€é–‹ç™ºè€…ã®çŸ¥è¦‹ã‚’æŒç¶šå¯èƒ½ãªçŸ¥è­˜è³‡ç”£ã¨ã—ã¦è“„ç©ã—ã¾ã™ã€‚
