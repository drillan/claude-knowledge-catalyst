"""Tests for Obsidian query builder functionality."""

import pytest
from pathlib import Path
from datetime import datetime, timedelta

from claude_knowledge_catalyst.obsidian.query_builder import (
    ObsidianQueryBuilder,
    QueryFilter,
    QueryResult,
    SortOption,
    FilterType
)


class TestObsidianQueryBuilder:
    """Test suite for ObsidianQueryBuilder."""

    @pytest.fixture
    def builder(self):
        """Create query builder instance."""
        return ObsidianQueryBuilder()

    def test_builder_initialization(self, builder):
        """Test query builder initialization."""
        assert builder is not None
        assert hasattr(builder, 'add_filter')
        assert hasattr(builder, 'set_sort')
        assert hasattr(builder, 'build_query')

    def test_basic_tag_filter(self, builder):
        """Test basic tag filtering."""
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        ))
        
        query = builder.build_query()
        assert isinstance(query, str)
        assert "python" in query.lower()

    def test_multiple_filters(self, builder):
        """Test multiple filter combinations."""
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        ))
        
        builder.add_filter(QueryFilter(
            type=FilterType.TYPE,
            value="code",
            operator="equals"
        ))
        
        query = builder.build_query()
        assert "python" in query.lower()
        assert "code" in query.lower()

    def test_date_range_filter(self, builder):
        """Test date range filtering."""
        start_date = datetime.now() - timedelta(days=30)
        end_date = datetime.now()
        
        builder.add_filter(QueryFilter(
            type=FilterType.DATE_RANGE,
            value={
                "start": start_date,
                "end": end_date
            },
            operator="between"
        ))
        
        query = builder.build_query()
        assert isinstance(query, str)
        # Should contain date-related query elements

    def test_complexity_filter(self, builder):
        """Test complexity level filtering."""
        builder.add_filter(QueryFilter(
            type=FilterType.COMPLEXITY,
            value="advanced",
            operator="equals"
        ))
        
        query = builder.build_query()
        assert "advanced" in query.lower()

    def test_technology_filter(self, builder):
        """Test technology stack filtering."""
        technologies = ["python", "javascript", "docker"]
        
        builder.add_filter(QueryFilter(
            type=FilterType.TECH,
            value=technologies,
            operator="in"
        ))
        
        query = builder.build_query()
        for tech in technologies:
            assert tech in query.lower()

    def test_sort_options(self, builder):
        """Test query sorting options."""
        # Test different sort options
        sort_options = [
            SortOption.DATE_CREATED_DESC,
            SortOption.DATE_UPDATED_DESC,
            SortOption.TITLE_ASC,
            SortOption.COMPLEXITY_ASC
        ]
        
        for sort_option in sort_options:
            builder.set_sort(sort_option)
            query = builder.build_query()
            assert isinstance(query, str)

    def test_query_result_model(self):
        """Test QueryResult model."""
        result = QueryResult(
            title="Test Result",
            path="test/path.md",
            tags=["python", "test"],
            created=datetime.now(),
            updated=datetime.now(),
            excerpt="This is a test excerpt",
            score=0.95
        )
        
        assert result.title == "Test Result"
        assert "python" in result.tags
        assert 0 <= result.score <= 1

    def test_query_filter_model(self):
        """Test QueryFilter model validation."""
        # Valid filter
        filter_obj = QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        )
        
        assert filter_obj.type == FilterType.TAG
        assert filter_obj.value == "python"
        assert filter_obj.operator == "contains"

    def test_complex_query_building(self, builder):
        """Test building complex queries with multiple criteria."""
        # Add multiple filters of different types
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value=["python", "web-dev"],
            operator="contains_any"
        ))
        
        builder.add_filter(QueryFilter(
            type=FilterType.TYPE,
            value="code",
            operator="equals"
        ))
        
        builder.add_filter(QueryFilter(
            type=FilterType.COMPLEXITY,
            value=["intermediate", "advanced"],
            operator="in"
        ))
        
        builder.set_sort(SortOption.DATE_UPDATED_DESC)
        
        query = builder.build_query()
        assert isinstance(query, str)
        assert len(query) > 0

    @pytest.mark.parametrize("filter_type,value,operator", [
        (FilterType.TAG, "python", "contains"),
        (FilterType.TYPE, "prompt", "equals"),
        (FilterType.DOMAIN, "web-dev", "contains"),
        (FilterType.STATUS, "production", "equals"),
        (FilterType.AUTHOR, "user123", "equals"),
    ])
    def test_filter_types_matrix(self, builder, filter_type, value, operator):
        """Test various filter type combinations."""
        builder.add_filter(QueryFilter(
            type=filter_type,
            value=value,
            operator=operator
        ))
        
        query = builder.build_query()
        assert isinstance(query, str)
        assert len(query) > 0

    def test_empty_query(self, builder):
        """Test building query with no filters."""
        query = builder.build_query()
        
        # Should return a valid query even with no filters
        assert isinstance(query, str)

    def test_query_reset(self, builder):
        """Test resetting query builder."""
        # Add some filters
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        ))
        
        builder.set_sort(SortOption.TITLE_ASC)
        
        # Reset
        builder.reset()
        
        # Should be empty after reset
        query = builder.build_query()
        assert isinstance(query, str)

    def test_filter_removal(self, builder):
        """Test removing specific filters."""
        # Add filters
        filter1 = QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        )
        
        filter2 = QueryFilter(
            type=FilterType.TYPE,
            value="code",
            operator="equals"
        )
        
        builder.add_filter(filter1)
        builder.add_filter(filter2)
        
        # Remove one filter
        builder.remove_filter(filter1)
        
        query = builder.build_query()
        assert "code" in query.lower()
        # python should be removed
        

class TestQueryBuilderIntegration:
    """Integration tests for query builder."""

    @pytest.fixture
    def builder(self):
        """Create query builder instance."""
        return ObsidianQueryBuilder()

    def test_integration_with_metadata_system(self, builder):
        """Test integration with metadata-based queries."""
        # Simulate metadata-driven query building
        metadata_criteria = {
            "tech": ["python", "javascript"],
            "type": "code",
            "complexity": "advanced",
            "status": "production"
        }
        
        # Build query from metadata
        for key, value in metadata_criteria.items():
            if key == "tech":
                filter_type = FilterType.TECH
            elif key == "type":
                filter_type = FilterType.TYPE
            elif key == "complexity":
                filter_type = FilterType.COMPLEXITY
            elif key == "status":
                filter_type = FilterType.STATUS
            else:
                continue
            
            builder.add_filter(QueryFilter(
                type=filter_type,
                value=value,
                operator="contains" if isinstance(value, list) else "equals"
            ))
        
        query = builder.build_query()
        assert isinstance(query, str)
        assert len(query) > 0

    def test_performance_with_complex_queries(self, builder):
        """Test performance with complex query building."""
        # Add many filters
        for i in range(10):
            builder.add_filter(QueryFilter(
                type=FilterType.TAG,
                value=f"tag-{i}",
                operator="contains"
            ))
        
        # Should handle many filters efficiently
        query = builder.build_query()
        assert isinstance(query, str)

    def test_real_world_query_scenarios(self, builder):
        """Test real-world query scenarios."""
        scenarios = [
            # Find all Python code snippets
            {
                "filters": [
                    QueryFilter(FilterType.TECH, "python", "contains"),
                    QueryFilter(FilterType.TYPE, "code", "equals")
                ],
                "sort": SortOption.DATE_UPDATED_DESC
            },
            
            # Find recent prompts for AI development
            {
                "filters": [
                    QueryFilter(FilterType.TYPE, "prompt", "equals"),
                    QueryFilter(FilterType.DOMAIN, "ai-ml", "contains"),
                    QueryFilter(FilterType.DATE_RANGE, {
                        "start": datetime.now() - timedelta(days=7),
                        "end": datetime.now()
                    }, "between")
                ],
                "sort": SortOption.DATE_CREATED_DESC
            },
            
            # Find advanced concepts for web development
            {
                "filters": [
                    QueryFilter(FilterType.DOMAIN, "web-dev", "contains"),
                    QueryFilter(FilterType.COMPLEXITY, ["advanced", "expert"], "in"),
                    QueryFilter(FilterType.TYPE, "concept", "equals")
                ],
                "sort": SortOption.TITLE_ASC
            }
        ]
        
        for scenario in scenarios:
            builder.reset()
            
            for filter_obj in scenario["filters"]:
                builder.add_filter(filter_obj)
            
            builder.set_sort(scenario["sort"])
            
            query = builder.build_query()
            assert isinstance(query, str)
            assert len(query) > 0


class TestQueryOptimization:
    """Test query optimization features."""

    @pytest.fixture
    def builder(self):
        """Create query builder instance."""
        return ObsidianQueryBuilder()

    def test_query_optimization(self, builder):
        """Test query optimization for performance."""
        # Add potentially redundant filters
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        ))
        
        builder.add_filter(QueryFilter(
            type=FilterType.TECH,
            value="python",
            operator="contains"
        ))
        
        # Should optimize redundant filters
        query = builder.build_query()
        assert isinstance(query, str)

    def test_query_validation(self, builder):
        """Test query validation before building."""
        # Add valid filters
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        ))
        
        # Should validate successfully
        is_valid = builder.validate_query()
        assert is_valid is True

    def test_query_explanation(self, builder):
        """Test query explanation for debugging."""
        builder.add_filter(QueryFilter(
            type=FilterType.TAG,
            value="python",
            operator="contains"
        ))
        
        builder.add_filter(QueryFilter(
            type=FilterType.TYPE,
            value="code",
            operator="equals"
        ))
        
        explanation = builder.explain_query()
        assert isinstance(explanation, str)
        assert "python" in explanation.lower()
        assert "code" in explanation.lower()


class TestFilterTypeEnum:
    """Test FilterType enum."""

    def test_filter_type_values(self):
        """Test FilterType enum values."""
        assert hasattr(FilterType, 'TAG')
        assert hasattr(FilterType, 'TYPE')
        assert hasattr(FilterType, 'TECH')
        assert hasattr(FilterType, 'DOMAIN')
        assert hasattr(FilterType, 'COMPLEXITY')
        assert hasattr(FilterType, 'STATUS')
        assert hasattr(FilterType, 'DATE_RANGE')
        assert hasattr(FilterType, 'AUTHOR')

    def test_sort_option_values(self):
        """Test SortOption enum values."""
        assert hasattr(SortOption, 'DATE_CREATED_ASC')
        assert hasattr(SortOption, 'DATE_CREATED_DESC')
        assert hasattr(SortOption, 'DATE_UPDATED_ASC')
        assert hasattr(SortOption, 'DATE_UPDATED_DESC')
        assert hasattr(SortOption, 'TITLE_ASC')
        assert hasattr(SortOption, 'TITLE_DESC')
        assert hasattr(SortOption, 'COMPLEXITY_ASC')
        assert hasattr(SortOption, 'COMPLEXITY_DESC')